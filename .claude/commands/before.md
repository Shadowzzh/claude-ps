---
description: 开始任务前的准备工作指南
---

# 任务启动前检查清单

<context>
指导 AI 在开始任何编码任务前，系统性地收集上下文、理解需求、评估影响。
</context>

<quick_reference>
  <purpose>确保充分理解后再动手</purpose>
  <principle>先调研，后规划，再执行</principle>
  <goal>避免返工、减少误解、提高效率</goal>
</quick_reference>

## 核心原则

<core_principles>
**三思而后行**:
1. 理解 → 规划 → 执行 → 验证
2. 不假设 - 通过探索确认
3. 不跳步 - 完成每个检查点
4. 先问后做 - 有疑问立即澄清
</core_principles>

## 阶段一：理解需求

<requirement_analysis>
**1. 明确任务目标**:
- 用户想要实现什么？
- 成功的标准是什么？
- 有哪些约束条件？

**2. 识别隐含需求**:
- 是否涉及安全性考虑？
- 是否需要向后兼容？
- 是否有性能要求？

**3. 确认理解**:
```text
我的理解是：
- 目标：[具体描述]
- 范围：[涉及哪些部分]
- 约束：[限制条件]

这样理解正确吗？
```

**关键问题**:
- 这是新功能还是修改现有功能？
- 是否有相关的设计文档或规范？
- 是否有类似的实现可以参考？
</requirement_analysis>

## 阶段二：收集上下文

<context_gathering>
**1. 项目结构探索**:
```bash
# 理解项目布局
tree -L 2 -I node_modules
ls -la

# 了解构建配置
cat package.json
cat tsconfig.json
```

**2. 相关代码定位**:
```bash
# 搜索相关文件
grep -r "关键字" src/ --include="*.ts"

# 查找类似实现
grep -r "similar_function" . --include="*.ts"
```

**3. 依赖关系分析**:
```bash
# 查看依赖
cat package.json | grep -A 20 "dependencies"

# 理解模块关系
grep -r "import.*from" src/ --include="*.ts" | grep "关键模块"
```

**检查清单**:
- [ ] 找到相关的源文件
- [ ] 理解现有的代码结构
- [ ] 识别可能受影响的模块
- [ ] 了解使用的技术栈和框架
</context_gathering>

## 阶段三：影响评估

<impact_assessment>
**1. 变更范围**:
- 需要修改哪些文件？
- 是否涉及公共 API 变更？
- 是否需要数据迁移？

**2. 风险识别**:
| 风险类型 | 检查点 |
|---------|--------|
| 破坏性变更 | 是否修改了导出接口？ |
| 性能影响 | 是否增加了复杂度？ |
| 安全风险 | 是否处理用户输入？ |
| 兼容性 | 是否影响现有功能？ |

**3. 测试策略**:
- 现有测试是否覆盖变更区域？
- 需要添加哪些新测试？
- 如何验证功能正确性？

**问题模板**:
```text
变更评估：
- 影响文件：[列表]
- 潜在风险：[描述]
- 测试计划：[策略]
- 回滚方案：[如有必要]
```
</impact_assessment>

## 阶段四：制定计划

<planning>
**1. 分解任务**:
- 将大任务拆分为小步骤
- 每个步骤可独立验证
- 确定执行顺序

**2. 识别依赖**:
- 哪些步骤可以并行？
- 哪些步骤必须串行？
- 是否需要外部资源？

**3. 计划模板**:
```text
执行计划：
1. [步骤1] - [目的]
2. [步骤2] - [目的]
3. [步骤3] - [目的]
...
验证方式：[如何确认完成]
```

**注意事项**:
- 优先处理高风险部分
- 保持每次提交的原子性
- 预留调试和测试时间
</planning>

## 阶段五：确认启动

<pre_flight_check>
**启动前最终检查**:

- [ ] **需求清晰** - 我完全理解要做什么
- [ ] **上下文完整** - 我知道相关代码在哪里
- [ ] **影响可控** - 我了解变更的影响范围
- [ ] **计划明确** - 我有清晰的执行步骤
- [ ] **风险可接受** - 潜在问题已识别并有对策

**如果任何一项未满足**:
1. 停下来
2. 识别缺失的信息
3. 通过探索或询问补齐
4. 重新检查

**准备就绪后**:
```text
准备开始执行：
- 任务：[简述]
- 首个步骤：[具体操作]
- 预期结果：[描述]

开始执行。
```
</pre_flight_check>

## 常见陷阱

<common_pitfalls>
**避免这些错误**:

| 陷阱 | 正确做法 |
|-----|---------|
| 直接开始写代码 | 先读懂现有代码 |
| 假设需求明确 | 主动确认理解 |
| 忽略边缘情况 | 考虑异常场景 |
| 过度设计 | 只做必要的事 |
| 跳过测试规划 | 提前考虑验证方式 |
| 忘记回滚方案 | 保持可撤销性 |

**危险信号**:
- "这应该很简单" → 可能遗漏复杂性
- "我记得在哪里见过" → 应该去确认
- "先改了再说" → 应该先理解影响
- "用户应该是这个意思" → 应该去澄清
</common_pitfalls>

## 快速检查模板

<quick_checklist>
**每次任务前快速过一遍**:

```text
[ ] 1. 需求确认
    - 目标是什么？
    - 成功标准是什么？

[ ] 2. 上下文收集
    - 相关代码在哪里？
    - 现有实现是怎样的？

[ ] 3. 影响评估
    - 会影响哪些模块？
    - 有什么风险？

[ ] 4. 计划制定
    - 分几步完成？
    - 如何验证？

[ ] 5. 启动确认
    - 准备好了吗？
    - 第一步是什么？
```
</quick_checklist>

## 特殊场景处理

<special_cases>
**Bug 修复**:
1. 先复现问题
2. 理解根本原因
3. 评估修复方案
4. 考虑回归风险

**紧急修复**:
1. 最小化变更范围
2. 优先恢复服务
3. 记录临时方案
4. 规划后续完善

**重构任务**:
1. 确保测试覆盖
2. 小步迭代修改
3. 每步验证行为不变
4. 保持提交粒度小

**新功能开发**:
1. 理解业务背景
2. 参考类似实现
3. 设计清晰接口
4. 规划测试策略
</special_cases>

## 执行原则

<execution_principles>
**核心要点**:
- 充分准备胜过盲目行动
- 理解问题比解决问题更重要
- 小步快跑，持续验证
- 有疑问就问，不要猜测

**记住**:
> 磨刀不误砍柴工。
> 花在准备上的时间，会在执行中加倍赚回来。
</execution_principles>
